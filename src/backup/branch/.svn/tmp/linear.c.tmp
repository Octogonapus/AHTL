#include <stdlib.h>
#include <string.h>
#ifdef SIMD
#include "simd.h"
#endif
#ifdef __MIC__
#define UNROLL_N 1
#else
#define UNROLL_N 1
#endif


#define UPDATE_TYPE 0 // 0 : store&read, 1 : extract
#ifdef SIMD
#ifdef __MIC__
static void printv_epi32(__m512i v, char *str)
{
  int i;
  __declspec(align(64)) int tmp[16];
  printf("%s:", str);
  _mm512_store_epi32(tmp, v);
  for(i=0; i < 16; i++)
  {
    tmp[0] = tmp[i];
    printf("[%d]=%d ", i, tmp[0]);
  }
  printf("\n");
}
#endif
#endif


#ifdef SIMD
int hist_linear_float_simd
(
 float * data, //data should be aligned
 float * boundary,
 unsigned int count,
 unsigned int * bin,
 unsigned int bin_count
)
{
#ifdef USE_GATHER_SCATTER
		int *simd_bin = _mm_malloc(bin_count*sizeof(unsigned int)*VLEN, 64);
		memset(simd_bin, 0, bin_count*sizeof(unsigned int)*VLEN);
#endif
		size_t remainder;
		size_t start = 0;
		unsigned int i;
		int j;
		if(remainder = ((unsigned long long int)data) % (VLEN * sizeof(float)))
		{
				unsigned int i;
				start = (VLEN - (remainder / sizeof(float)));
				for(i = 0; i < start; i++)
				{
						float d = data[i];
						for(j = bin_count-1; d < boundary[j]; j--);
						bin[j]++;
				}
		}
#ifdef __MIC__
		__m512i offsets = _mm512_set_epi32(15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0);
		__m512i t = _mm512_set1_epi32(1);
#endif

		unsigned int n = bin_count;
		_VECTOR * v_boundary = _mm_malloc(sizeof(_VECTOR) * (n + 1),64);

		for( i = 0; i < n+1; i++)
		{
			v_boundary[i] = _MM_SET1(boundary[i]);
		}

#ifdef NO_UPDATE
		int tmpForReduction = 0;
#endif
		for(i = start; i+VLEN < count; i+=VLEN)
		{
			_VECTOR tmp = _MM_LOAD(data + i);
#ifdef SSE
			__m128i c1 = _mm_set1_epi32(0);
			for(j = 1; j < n+1; j++)
			{
					__m128i t = _mm_castps_si128( _mm_cmp_ps(tmp, v_boundary[j],_CMP_GE_OS));
					c1 = _mm_add_epi32(c1, t);
			}
			unsigned int i1 = (unsigned)-_mm_extract_epi32(c1, 0); 
			unsigned int i2 = (unsigned)-_mm_extract_epi32(c1, 1); 
			unsigned int i3 = (unsigned)-_mm_extract_epi32(c1, 2); 
			unsigned int i4 = (unsigned)-_mm_extract_epi32(c1, 3); 
#ifdef NO_UPDATE
			tmpForReduction += i1;
			tmpForReduction += i2;
			tmpForReduction += i3;
			tmpForReduction += i4;
#else
			bin[i1]++;
			bin[i2]++;
			bin[i3]++;
			bin[i4]++;
#endif
#elif AVX
			__m128i c1 = _mm_set1_epi32(0);
			__m128i c2 = _mm_set1_epi32(0);
#pragma unroll(UNROLL_N)
			for(j = 1; j < n+1; j++)
			{
				__m256i t = _mm256_castps_si256( _mm256_cmp_ps(tmp, v_boundary[j], _CMP_GE_OS));
				c1 = _mm_add_epi32(c1, _mm256_extractf128_si256(t, 0));
				c2 = _mm_add_epi32(c2, _mm256_extractf128_si256(t, 1));
			}
#if UPDATE_TYPE == 0
#ifdef NO_UPDATE
		__declspec(align(64)) int buf[8];
		tmpForReduction += (unsigned)-_mm_extract_epi32(c1, 0);
		tmpForReduction += (unsigned)-_mm_extract_epi32(c2, 0);
			tmpForReduction += buf[2];
			tmpForReduction += buf[3];
			tmpForReduction += buf[4];
			tmpForReduction += buf[5];
			tmpForReduction += buf[6];
			tmpForReduction += buf[7];
#else
		__declspec(align(16)) int buf1[4];
		__declspec(align(16)) int buf2[4];
		_mm_store_si128(buf1, c1);
		_mm_store_si128(buf2, c2);
		bin[-buf1[0]]++;
		bin[-buf1[1]]++;
		bin[-buf1[2]]++;
		bin[-buf1[3]]++;
		bin[-buf2[0]]++;
		bin[-buf2[1]]++;
		bin[-buf2[2]]++;
		bin[-buf2[3]]++;
#endif
#else
#ifdef NO_UPDATE
		tmpForReduction += (unsigned)-_mm_extract_epi32(c1, 0);
		tmpForReduction += (unsigned)-_mm_extract_epi32(c1, 1);
		tmpForReduction += (unsigned)-_mm_extract_epi32(c1, 2);
		tmpForReduction += (unsigned)-_mm_extract_epi32(c1, 3);
		tmpForReduction += (unsigned)-_mm_extract_epi32(c2, 0);
		tmpForReduction += (unsigned)-_mm_extract_epi32(c2, 1);
		tmpForReduction += (unsigned)-_mm_extract_epi32(c2, 2);
		tmpForReduction += (unsigned)-_mm_extract_epi32(c2, 3);
#else
		bin[(unsigned)-_mm_extract_epi32(c1, 0)]++;
		bin[(unsigned)-_mm_extract_epi32(c1, 1)]++;
		bin[(unsigned)-_mm_extract_epi32(c1, 2)]++;
		bin[(unsigned)-_mm_extract_epi32(c1, 3)]++;
		bin[(unsigned)-_mm_extract_epi32(c2, 0)]++;
		bin[(unsigned)-_mm_extract_epi32(c2, 1)]++;
		bin[(unsigned)-_mm_extract_epi32(c2, 2)]++;
		bin[(unsigned)-_mm_extract_epi32(c2, 3)]++;
#endif
#endif

#elif __MIC__
			__m512i c = _mm512_set1_epi32(0);
#if 0
			for(j = 1; j < n+1; j+=4)
			{
				__mmask16 m1 = _mm512_cmp_ps_mask(tmp, v_boundary[j], _CMP_GE_OS);
				__mmask16 m2 = _mm512_cmp_ps_mask(tmp, v_boundary[j+1], _CMP_GE_OS);
				c = _mm512_mask_add_epi32(c, m1, c, t);
				c = _mm512_mask_add_epi32(c, m2, c, t);
			}
#else
#pragma unroll(UNROLL_N)
			for(j = 1; j < n+1; j++)
			{
				c = _mm512_mask_add_epi32(c, _mm512_cmp_ps_mask(tmp, v_boundary[j], _CMP_GE_OS), c, t);
			}
#endif
#ifdef USE_GATHER_SCATTER

			c = _mm512_fmadd_epi32(c, _mm512_set1_epi32(16), offsets);
			__m512i cnts = _mm512_i32gather_epi32(c, simd_bin, _MM_SCALE_4);
			cnts = _mm512_add_epi32(cnts, _mm512_set1_epi32(1));
			_mm512_i32scatter_epi32(simd_bin, c, cnts, _MM_SCALE_4);
#else
			__declspec(align(64)) int buf[16];
#ifdef NO_UPDATE
			tmpForReduction += buf[0];
			tmpForReduction += buf[1];
			tmpForReduction += buf[2];
			tmpForReduction += buf[3];
			tmpForReduction += buf[4];
			tmpForReduction += buf[5];
			tmpForReduction += buf[6];
			tmpForReduction += buf[7];
			tmpForReduction += buf[8];
			tmpForReduction += buf[9];
			tmpForReduction += buf[10];
			tmpForReduction += buf[11];
			tmpForReduction += buf[12];
			tmpForReduction += buf[13];
			tmpForReduction += buf[14];
			tmpForReduction += buf[15];
#else
			_mm512_store_epi32(buf, c);
			bin[buf[0]]++;
			bin[buf[1]]++;
			bin[buf[2]]++;
			bin[buf[3]]++;
			bin[buf[4]]++;
			bin[buf[5]]++;
			bin[buf[6]]++;
			bin[buf[7]]++;
			bin[buf[8]]++;
			bin[buf[9]]++;
			bin[buf[10]]++;
			bin[buf[11]]++;
			bin[buf[12]]++;
			bin[buf[13]]++;
			bin[buf[14]]++;
			bin[buf[15]]++;
#endif
#endif
#endif
		}

#ifdef USE_GATHER_SCATTER

		for (j = 0; j < bin_count; j++)
		{
				bin[j] += _mm512_reduce_add_epi32(((__m512i *)simd_bin)[j]);
		}
		_mm_free(simd_bin);
#endif

#ifdef NO_UPDATE
		bin[0] += tmpForReduction;
#endif

		for(; i < count; i++)
		{
			float d = data[i];
			for(j = bin_count-1; d < boundary[j]; j--);
			bin[j]++;
		}
		_mm_free(v_boundary);
		return 0;
}
#endif

int hist_linear_float 
(
 float * data, 
 float * boundary,
 unsigned int count,
 unsigned int * bin,
 unsigned int bin_count
)
{
		int i, j;
		for(i = 0; i < count; i++){
			float d = data[i];
			for(j = bin_count-1; d < boundary[j]; j--);
			bin[j]++;
		}
		return 0;
}
